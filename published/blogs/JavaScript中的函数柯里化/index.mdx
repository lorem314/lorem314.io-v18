---
title: JavaScript 中的函数柯里化
tags:
  - JavaScript
  - 函数柯里化
  - 算法
date: 2024-10-26
---

[B站视频讲解](https://www.bilibili.com/video/BV1mQ1aY4Ezn/)

柯里化是函数的一种高级用法。

柯里化不会执行函数，而是把函数从以一次性接收参数而被执行的方式，转化为可以多次接收参数、直到接收到了足够多的参数后才被执行的方式。

举个例子：

```js noLineNumber
function sum(a, b, c) {
  return a + b + c;
}
```

一个接收三个数值参数，并返回这三个参数之和的函数 `sum(a, b, c)` 。

一般地，我们会通过一次性传入三个参数的方式，去调用这个函数：

```js noLineNumber
sum(1, 2, 3)
```

用 `curry` 函数，将 `sum` 函数柯里化之后：

```js noLineNumber
const curriedSum = curry(sum)
```

得到 `curriedSum` 函数。

我们便可以按照如下的方式来进行调用：

```js noLineNumber
// 可以分三次传入参数
curriedSum(1)(2)(3)

// 或是分两次传入参数
curriedSum(1, 2)(3)
curriedSum(1)(2, 3)

// 还可以跟前一样，一次性传入所有的参数
curriedSum(1, 2, 3)

// 传入的参数比原函数所需的多，多出来的则会被忽略
curriedSum(1, 2)(3, 4)
curriedSum(1, 2, 3, 4)

// 以上 都可以得到同样的结果 6
```

传入 `curriedSum` 函数的参数比执行原函数 `sum` 所需要的参数少时，并不会执行 `sum` 函数，而是会返回另一个函数，继续接收参数，直到接收到足够多的参数后，才会执行 `sum` 函数。

下面我们来编写 `curry` 函数。

```js noLineNumber
function curry(fn) {
  return function curried(...args) {
    if(args.length >= fn.length) {
      return fn(...args)
    } else {
      return (...rest) => curried(...args, ...rest)
    }
  }
}
```

首先，`curry` 函数接受一个参数，原函数 `fn`。如之前所说，柯里化并不执行函数，只改变函数的执行方式。所以在 `curry` 函数中所需要做的，就是直接返回一个函数，由于这个返回的函数，之后会在自身的函数体中通过递归的方式调用自身，所以在这里需要起一个名字，就叫 `curried`。

`curried` 函数通过**剩余参数**的方式接收参数，将所有参数看作为一个数组 `args`。之后，一旦 `curried` 函数接收了参数，无论是分几次传入，都需要判断参数的数量是否足够多，是否满足执行原函数 `fn` 需要的参数数量。

`curried` 函数所接收到的参数的数量，我们可以通过访问数组 `args` 的 `length` 属性获得；原函数 `fn` 所需的参数数量，也可以通过访问 `fn` 的 `length` 属性获得。之后要通过 `if` 语句来分情况讨论。

如果 `args.length` 大于等于 `fn.length`，说明接收到了足够多的参数，可以执行原函数，那么就将接收到的参数 `args` 通过**展开语法**的方式传入原函数 `fn`，并返回结果。

若不满足条件，说明参数不够，需要继续接收参数，而只有函数能接收参数，所以又要继续返回函数。这里返回的是一个匿名的箭头函数。

同样，该函数通过**剩余参数**的方式接收参数，并将之前 `curried` 函数中接收到的参数 `args` 和自身接收到的参数 `rest` 一并传入通过递归调用的 `curried` 函数中，并返回结果。

这说明，如果接收了一次参数的 `curried` 函数，不满足执行原函数 `fn` 的条件，所返回的函数再一次接收到了参数后，需要将之前所接收到的参数 `args` 和之后接收到的参数 `rest` ，按照先后顺序放在一起，传入 `curried` 函数中，再一次，通过 `if` 语句判断，是否满足执行原函数 `fn` 的条件。若满足，则将参数传入原函数 `fn` 中执行，并返回结果；若不满足，则继续返回函数，接收参数。

至此，我们实现了 `curry` 函数。